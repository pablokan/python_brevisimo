{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udc0dPython Brev\u00edsimo\ud83d\udc0d","text":""},{"location":"#apunte-de-catedra-de-programacion-1-de-itec-rio-cuarto","title":"Apunte de C\u00e1tedra de Programaci\u00f3n 1 de iTec R\u00edo Cuarto","text":"<p>documentaci\u00f3n escrita por:  kan / Pablo Kaniefsky / email: pablokan@itecriocuarto.org.ar (actualizado 2025)</p> <p>Este es fue un apunte de Python nivel introductorio agn\u00f3stico al sistema operativo (utilizo en esta materia, de manera indistinta, equipos con Linux, MacOS, ChromeOS y Windows ning\u00fan otro). Casi ya no uso No uso para nada Windows en los \u00faltimos a\u00f1os pero en este caso har\u00e9 el esfuerzo y ya no har\u00e9 el esfuerzo (quiero ense\u00f1ar a programar y Windows ese otro sistema operativo es hartante!!!! \ud83d\ude20).</p> <p>Despu\u00e9s de m\u00e1s de 30 a\u00f1os de docencia en general y m\u00e1s de 10 de ense\u00f1ar Python, escribo y reescribo este apunte porque tengo demasiados alumnos y temo no poder llegar bien a todos ustedes.</p> <p>Sin m\u00e1s, vamos al tema!</p>"},{"location":"#convenciones-de-uso-de-esta-documentacion","title":"Convenciones de uso de esta documentaci\u00f3n","text":"<p>TL;DR</p> <p>Si agrego TL;DR (abreviatura en ingl\u00e9s de \"Too Long; Didn't Read\" -en espa\u00f1ol, \"demasiado largo; no lo he le\u00eddo\"-), significa que es un resumen para que no se estresen leyendo todo lo que sigue!</p> <p>Los bloques de c\u00f3digo est\u00e1n escritos para ser copiados y pegados para su ejecuci\u00f3n directa:</p> <pre><code># Comentario en Python, siempre comienzan con el signo numeral(hash)\n# Lo que sigue es tu primer programa en Python!\nprint(\"hola mundo!\")\n</code></pre> <p>En la esquina superior derecha tienen el S\u00edmbolo de Copiar al portapapeles:  para tener disponible todo el c\u00f3digo Python dentro del \u00e1rea gris para luego ser pegado en el Editor (v\u00eda bot\u00f3n derecho, opci\u00f3n Paste/Pegar o con el teclado usando la combinaci\u00f3n de teclas Ctrl-V)</p> <p>Tendremos enlaces internos (a otros documentos de este Apunte), como por ejemplo: Introducci\u00f3n, que tambi\u00e9n estar\u00e1n en el Men\u00fa Superior o en el Panel Izquierdo. Las secciones de cada p\u00e1gina las tendremos en el Panel Derecho.</p> <p>Y tambi\u00e9n encontraremos enlaces a p\u00e1ginas externas: Sitio Oficial de Python</p>"},{"location":"archivos/","title":"Manejo de Archivos en Python - Documentaci\u00f3n Oficial","text":""},{"location":"archivos/#funcion-open","title":"Funci\u00f3n open()","text":"<p>La funci\u00f3n built-in <code>open()</code> retorna un objeto file, y es la forma est\u00e1ndar de abrir archivos en Python.</p>"},{"location":"archivos/#sintaxis-basica","title":"Sintaxis B\u00e1sica","text":"<pre><code>open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)\n</code></pre>"},{"location":"archivos/#modos-de-apertura","title":"Modos de Apertura","text":"<ul> <li><code>'r'</code>: Solo lectura (default)</li> <li><code>'w'</code>: Solo escritura (trunca el archivo)</li> <li><code>'x'</code>: Creaci\u00f3n exclusiva</li> <li><code>'a'</code>: Append (agregar al final)</li> <li><code>'b'</code>: Modo binario</li> <li><code>'t'</code>: Modo texto (default)</li> <li><code>'+'</code>: Lectura y escritura</li> </ul>"},{"location":"archivos/#administrador-de-contexto-with","title":"Administrador de Contexto (with)","text":"<p>El statement <code>with</code> se introdujo en Python 2.5 (PEP 343) como una forma m\u00e1s limpia de manejar excepciones y limpieza de recursos.</p>"},{"location":"archivos/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Implementa el protocolo de administraci\u00f3n de contexto (enter y exit)</li> <li>Garantiza que el archivo se cierre apropiadamente</li> <li>Maneja autom\u00e1ticamente las excepciones</li> </ul>"},{"location":"archivos/#metodos-principales-de-objetos-file","title":"M\u00e9todos Principales de Objetos File","text":""},{"location":"archivos/#lectura","title":"Lectura","text":"<ul> <li><code>read(size=-1)</code>: Lee el archivo completo o 'size' bytes</li> <li><code>readline()</code>: Lee una l\u00ednea</li> <li><code>readlines()</code>: Lee todas las l\u00edneas en una lista</li> <li><code>seek(offset, whence=0)</code>: Mueve el cursor del archivo</li> </ul>"},{"location":"archivos/#escritura","title":"Escritura","text":"<ul> <li><code>write(str)</code>: Escribe una cadena al archivo</li> <li><code>writelines(lines)</code>: Escribe una lista de l\u00edneas</li> <li><code>flush()</code>: Fuerza la escritura del buffer</li> </ul>"},{"location":"archivos/#control","title":"Control","text":"<ul> <li><code>close()</code>: Cierra el archivo</li> <li><code>closed</code>: Propiedad que indica si el archivo est\u00e1 cerrado</li> <li><code>mode</code>: Modo de apertura del archivo</li> <li><code>name</code>: Nombre del archivo</li> </ul>"},{"location":"archivos/#mejores-practicas","title":"Mejores Pr\u00e1cticas","text":"<ol> <li> <p>Uso de with <pre><code>with open('archivo.txt') as f:\n    data = f.read()\n</code></pre></p> </li> <li> <p>Manejo de Encoding <pre><code>with open('archivo.txt', encoding='utf-8') as f:\n    texto = f.read()\n</code></pre></p> </li> <li> <p>Procesamiento por L\u00edneas <pre><code>with open('archivo.txt') as f:\n    for linea in f:\n        proceso(linea)\n</code></pre></p> </li> </ol>"},{"location":"archivos/#notas-importantes","title":"Notas Importantes","text":"<ol> <li>Los archivos se cierran autom\u00e1ticamente cuando:</li> <li>El bloque <code>with</code> termina</li> <li> <p>El objeto file es recolectado por el garbage collector</p> </li> <li> <p>Es una buena pr\u00e1ctica especificar siempre el encoding al abrir archivos de texto</p> </li> <li> <p>Para archivos grandes, es preferible leer por l\u00edneas en lugar de cargar todo el archivo en memoria</p> </li> <li> <p>El modo binario ('b') es necesario para archivos no textuales</p> </li> </ol>"},{"location":"archivos/#consideraciones-de-rendimiento","title":"Consideraciones de Rendimiento","text":"<ol> <li><code>readlines()</code> carga todo el archivo en memoria</li> <li>La iteraci\u00f3n directa sobre el archivo es m\u00e1s eficiente</li> <li><code>writelines()</code> no agrega saltos de l\u00ednea autom\u00e1ticamente</li> <li>El buffering puede afectar el rendimiento</li> </ol>"},{"location":"archivos/#excepciones-comunes","title":"Excepciones Comunes","text":"<ul> <li><code>FileNotFoundError</code>: Archivo no encontrado</li> <li><code>PermissionError</code>: Permisos insuficientes</li> <li><code>IsADirectoryError</code>: Se intent\u00f3 abrir un directorio</li> <li><code>UnicodeDecodeError</code>: Error de decodificaci\u00f3n</li> </ul>"},{"location":"chromebook/","title":"Chromebook Page","text":"<p>Trying to update from Duet5</p>"},{"location":"ejemplo2_persona_old/","title":"Ejemplo2 persona old","text":""},{"location":"ejemplo2_persona_old/#ejemplo-2","title":"Ejemplo #2:","text":"<pre><code>class Persona:\n    def __init__(self, n, e): # constructor: inicializa los atributos\n        self.nombre = n # atributo: variable que representa una caracter\u00edstica del objeto\n        self.edad = e # otro atributo\n\n    def saludo(self): # el self representa al objeto que se va a crear\n        return  \"Hola \" + self.nombre + \" ten\u00e9s \" + str(self.edad) + \" a\u00f1os.\"\n\n    def adulto(self): # las funciones dentro de los objetos se llaman m\u00e9todos\n        if self.edad &gt;= 18:\n            return True\n        else:\n            return False\n\n    def esAdulto(self):\n        if self.adulto():\n            return \"si, es adulto\"\n        else:\n            return \"no, a\u00fan no es adulto\"\n\npibe = Persona(\"Jos\u00e9\", 13) # creaci\u00f3n del objeto o instancia\nprofesora = Persona(\"Ana\", 35) # otra instanciaci\u00f3n\nbebito = Persona(\"Benjam\u00edn\", 1) # los argumentos se reciben en los par\u00e1metros del constructor\n\nprint(profesora.saludo()) # los m\u00e9todos siempre llevan par\u00e9ntesis\nprint(\"Es adulto?\", pibe.esAdulto()) # este m\u00e9todo devuelve una variable booleana\nprint(\"El beb\u00e9 se llama\", bebito.nombre) # muestra el atributo directamente\n</code></pre>"},{"location":"python-tutorial/","title":"Tutorial de Python: De B\u00e1sico a OOP","text":"<p>Un repaso completo para programadores principiantes</p>"},{"location":"python-tutorial/#tabla-de-contenidos","title":"Tabla de Contenidos","text":"<ol> <li>Configuraci\u00f3n del Entorno</li> <li>Conceptos B\u00e1sicos</li> <li>Estructuras de Control</li> <li>Funciones</li> <li>Estructuras de Datos</li> <li>Programaci\u00f3n Orientada a Objetos</li> <li>Manejo de Archivos</li> <li>Gesti\u00f3n de Paquetes y M\u00f3dulos</li> <li>Proyecto Final</li> </ol>"},{"location":"python-tutorial/#configuracion-del-entorno","title":"Configuraci\u00f3n del Entorno","text":""},{"location":"python-tutorial/#instalacion-de-python","title":"Instalaci\u00f3n de Python","text":"<ol> <li>Descarga Python desde python.org</li> <li>Instala asegur\u00e1ndote de marcar \"Add Python to PATH\"</li> </ol>"},{"location":"python-tutorial/#configuracion-de-uv-gestor-de-entornos-virtuales","title":"Configuraci\u00f3n de uv (Gestor de Entornos Virtuales)","text":"<pre><code># Instalar uv\npip install uv\n\n# Crear un nuevo entorno virtual\nuv venv\n\n# Activar el entorno virtual\n# En Windows:\n.venv\\Scripts\\activate\n# En Unix/MacOS:\nsource .venv/bin/activate\n</code></pre>"},{"location":"python-tutorial/#conceptos-basicos","title":"Conceptos B\u00e1sicos","text":""},{"location":"python-tutorial/#variables-y-tipos-de-datos","title":"Variables y Tipos de Datos","text":"<pre><code># Tipos b\u00e1sicos\nnombre = \"Ana\"  # str\nedad = 25      # int\naltura = 1.75  # float\nes_estudiante = True  # bool\n\n# Print con formato\nprint(f\"Me llamo {nombre} y tengo {edad} a\u00f1os\")\n</code></pre>"},{"location":"python-tutorial/#operadores","title":"Operadores","text":"<pre><code># Aritm\u00e9ticos\nsuma = 5 + 3\nresta = 10 - 4\nmultiplicacion = 6 * 2\ndivision = 15 / 3\ndivision_entera = 15 // 2\nmodulo = 15 % 2\npotencia = 2 ** 3\n\n# Comparaci\u00f3n\nigual = 5 == 5\ndiferente = 5 != 3\nmayor = 5 &gt; 3\nmenor = 3 &lt; 5\n</code></pre>"},{"location":"python-tutorial/#estructuras-de-control","title":"Estructuras de Control","text":""},{"location":"python-tutorial/#condicionales","title":"Condicionales","text":"<pre><code>edad = 18\n\nif edad &gt;= 18:\n    print(\"Eres mayor de edad\")\nelif edad &gt;= 13:\n    print(\"Eres adolescente\")\nelse:\n    print(\"Eres menor de edad\")\n</code></pre>"},{"location":"python-tutorial/#bucles","title":"Bucles","text":"<pre><code># While\ncontador = 0\nwhile contador &lt; 5:\n    print(contador)\n    contador += 1\n\n# For\nfor i in range(5):\n    print(i)\n\n# For con lista\nfrutas = [\"manzana\", \"pera\", \"uva\"]\nfor fruta in frutas:\n    print(fruta)\n</code></pre>"},{"location":"python-tutorial/#funciones","title":"Funciones","text":""},{"location":"python-tutorial/#definicion-y-uso","title":"Definici\u00f3n y Uso","text":"<pre><code>def saludar(nombre, edad=None):\n    if edad:\n        return f\"Hola {nombre}, tienes {edad} a\u00f1os\"\n    return f\"Hola {nombre}\"\n\n# Llamadas a funci\u00f3n\nprint(saludar(\"Juan\"))\nprint(saludar(\"Ana\", 25))\n\n# Funci\u00f3n con argumentos variables\ndef suma(*args):\n    return sum(args)\n\nprint(suma(1, 2, 3, 4))  # 10\n</code></pre>"},{"location":"python-tutorial/#estructuras-de-datos","title":"Estructuras de Datos","text":""},{"location":"python-tutorial/#listas","title":"Listas","text":"<pre><code># Creaci\u00f3n y manipulaci\u00f3n\nnumeros = [1, 2, 3, 4, 5]\nnumeros.append(6)\nnumeros.pop()\nprimer_elemento = numeros[0]\nultimo_elemento = numeros[-1]\n\n# List comprehension\ncuadrados = [x**2 for x in range(5)]\n</code></pre>"},{"location":"python-tutorial/#diccionarios","title":"Diccionarios","text":"<pre><code># Creaci\u00f3n y acceso\npersona = {\n    \"nombre\": \"Juan\",\n    \"edad\": 25,\n    \"ciudad\": \"Madrid\"\n}\n\nprint(persona[\"nombre\"])\npersona[\"profesion\"] = \"Programador\"\n\n# Iteraci\u00f3n\nfor clave, valor in persona.items():\n    print(f\"{clave}: {valor}\")\n</code></pre>"},{"location":"python-tutorial/#programacion-orientada-a-objetos","title":"Programaci\u00f3n Orientada a Objetos","text":""},{"location":"python-tutorial/#clases-y-objetos","title":"Clases y Objetos","text":"<pre><code>class Persona:\n    def __init__(self, nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n\n    def saludar(self):\n        return f\"Hola, soy {self.nombre}\"\n\n    @property\n    def es_mayor_edad(self):\n        return self.edad &gt;= 18\n\n# Uso de la clase\njuan = Persona(\"Juan\", 25)\nprint(juan.saludar())\nprint(juan.es_mayor_edad)\n</code></pre>"},{"location":"python-tutorial/#herencia","title":"Herencia","text":"<pre><code>class Estudiante(Persona):\n    def __init__(self, nombre, edad, carrera):\n        super().__init__(nombre, edad)\n        self.carrera = carrera\n\n    def estudiar(self):\n        return f\"Estoy estudiando {self.carrera}\"\n\n# Uso de la herencia\nana = Estudiante(\"Ana\", 20, \"Inform\u00e1tica\")\nprint(ana.saludar())\nprint(ana.estudiar())\n</code></pre>"},{"location":"python-tutorial/#manejo-de-archivos","title":"Manejo de Archivos","text":""},{"location":"python-tutorial/#lectura-y-escritura","title":"Lectura y Escritura","text":"<pre><code># Escribir archivo\nwith open(\"ejemplo.txt\", \"w\") as f:\n    f.write(\"Hola mundo\\n\")\n    f.write(\"Segunda l\u00ednea\")\n\n# Leer archivo\nwith open(\"ejemplo.txt\", \"r\") as f:\n    contenido = f.read()\n    print(contenido)\n\n# Leer l\u00ednea por l\u00ednea\nwith open(\"ejemplo.txt\", \"r\") as f:\n    for linea in f:\n        print(linea.strip())\n</code></pre>"},{"location":"python-tutorial/#gestion-de-paquetes-y-modulos","title":"Gesti\u00f3n de Paquetes y M\u00f3dulos","text":""},{"location":"python-tutorial/#estructura-de-proyecto","title":"Estructura de Proyecto","text":"<pre><code>mi_proyecto/\n\u2502\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 utils/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 helpers.py\n\u2502\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 test_main.py\n\u2502\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"python-tutorial/#creacion-de-modulos","title":"Creaci\u00f3n de M\u00f3dulos","text":"<pre><code># helpers.py\ndef validar_edad(edad):\n    return edad &gt;= 0 and edad &lt;= 120\n\ndef formatear_nombre(nombre):\n    return nombre.strip().title()\n\n# main.py\nfrom utils.helpers import validar_edad, formatear_nombre\n\ndef procesar_usuario(nombre, edad):\n    if validar_edad(edad):\n        nombre_formateado = formatear_nombre(nombre)\n        return f\"Usuario: {nombre_formateado}, Edad: {edad}\"\n    return \"Edad inv\u00e1lida\"\n</code></pre>"},{"location":"python-tutorial/#gestion-de-dependencias","title":"Gesti\u00f3n de Dependencias","text":"<pre><code># Crear requirements.txt\nuv pip freeze &gt; requirements.txt\n\n# Instalar dependencias\nuv pip install -r requirements.txt\n</code></pre>"},{"location":"python-tutorial/#proyecto-final","title":"Proyecto Final","text":""},{"location":"python-tutorial/#gestor-de-tareas-simple","title":"Gestor de Tareas Simple","text":"<pre><code># task_manager.py\nclass Task:\n    def __init__(self, title, description=\"\"):\n        self.title = title\n        self.description = description\n        self.completed = False\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n\n    def add_task(self, title, description=\"\"):\n        task = Task(title, description)\n        self.tasks.append(task)\n        return len(self.tasks) - 1  # retorna el \u00edndice\n\n    def complete_task(self, index):\n        if 0 &lt;= index &lt; len(self.tasks):\n            self.tasks[index].completed = True\n            return True\n        return False\n\n    def list_tasks(self):\n        for i, task in enumerate(self.tasks):\n            status = \"\u2713\" if task.completed else \" \"\n            print(f\"[{status}] {i}: {task.title}\")\n\n# main.py\ndef main():\n    manager = TaskManager()\n\n    while True:\n        print(\"\\n1. Agregar tarea\")\n        print(\"2. Completar tarea\")\n        print(\"3. Listar tareas\")\n        print(\"4. Salir\")\n\n        opcion = input(\"\\nSeleccione una opci\u00f3n: \")\n\n        if opcion == \"1\":\n            titulo = input(\"T\u00edtulo de la tarea: \")\n            desc = input(\"Descripci\u00f3n (opcional): \")\n            manager.add_task(titulo, desc)\n        elif opcion == \"2\":\n            index = int(input(\"\u00cdndice de la tarea: \"))\n            manager.complete_task(index)\n        elif opcion == \"3\":\n            manager.list_tasks()\n        elif opcion == \"4\":\n            break\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Este tutorial cubre los conceptos fundamentales de Python y proporciona una base s\u00f3lida para comenzar a programar. Para profundizar en cualquier tema, se recomienda consultar la documentaci\u00f3n oficial de Python y practicar con ejercicios adicionales.</p>"},{"location":"repaso/","title":"Repaso r\u00e1pido","text":""},{"location":"repaso/#para-copiar-y-pegar-en-el-editor-y-probar-que-sale","title":"(para copiar y pegar en el editor y probar que sale)","text":"<pre><code># Primer programa \nprint(\u201cHola mundo\u201d)\n</code></pre> <p>Variables y sus Tipos de datos:</p>"},{"location":"repaso/#esto-es-un-comentario-porque-empieza-con-numeral","title":"Esto es un comentario porque empieza con numeral","text":""},{"location":"repaso/#variables","title":"Variables","text":"<p>nombre = \u201cJos\u00e9\u201d # string edad = 34 # int altura = 1.87 # float</p> <p>print(\u201cHola\u201d, nombre, \u201c,ten\u00e9s\u201d, edad, \u201ca\u00f1os y med\u00eds\u201d, altura)</p> <p>La salida por pantalla ser\u00eda: Hola Jos\u00e9, ten\u00e9s 34 a\u00f1os y med\u00eds 1.87</p> <p>Tomar datos:</p> <p>nombre = input(\u201cIngrese su nombre: \u201c) edad = int(input(\u201cIngrese su edad: \u201c))  # input toma siempre string, por lo tanto si quiero tomar entero debo aplicar la funci\u00f3n int </p> <p>``` Alternativa:</p> <p>if , ejemplo:  if nombre == \u201cJuan\u201d, if edad &gt; 27, if altura &lt;= 1.80 <p>if edad &gt;= 18:     print(\u201ces mayor de edad\u201d) else: # sino     print(\u201ces menor de edad\u201d)</p> <p>Observar que el bloque que depende del if est\u00e1 indentado (tabulado), 4 espacios a la derecha.</p> <p>Repetitivas:</p> <p>Dos instrucciones:</p> <p>for, para cuando tendremos una cantidad fija de repeticiones while, para cantidad indefinida con condici\u00f3n</p> <p>for vr in range(vi, vf): # para una variable de recorrido que va desde valor inicial a valor final -1     print(\u201chola\u201d)     print(vr) # si vi=5 y vf=10 entonces la salida ser\u00eda: 5 - 6 - 7 - 8 - 9     print(\u201cchau\u201d)</p> <p>cuentaRegresiva = 10 while cuentaRegresiva &gt; 0: # condici\u00f3n con valor de verdad, como el if     print(\u201chola\u201d)     cuentaRegresiva = cuentaRegresiva - 1     print(cuentaRegresiva)</p> <p>Contadores y Acumuladores En los procesos repetitivos, es habitual usar contadores y acumuladores. Los contadores son variables que se incrementan de a una unidad, ejemplo: n = n + 1 y los acumuladores son totalizadores del tipo: totalSueldos = totalSueldos + sueldo</p>"},{"location":"colecciones/","title":"Estructuras de Datos","text":"<p>Las estructuras de datos, tambi\u00e9n llamadas colecciones o tipos de datos compuestos, se implementan en Python como variables de almacenamiento m\u00faltiple.</p> <p>Las m\u00e1s usuales son las listas, tuplas, strings, diccionarios y conjuntos.</p> <p>Las strings son un caso particular, porque si bien son un tipo b\u00e1sico como int, y en ese sentido se las trata como variables comunes que almancenan un solo valor, alternativamente pueden ser tratadas como tuplas de caracteres, de tal manera que se pueden, por ejemplo, recorrer con un for.</p>"},{"location":"colecciones/cadenas/","title":"Cadenas","text":"<p>Las cadenas (strings, tipo de dato str) son variables o constantes (literales) muy potentes.</p> <p>Primero lo m\u00e1s simple, recuerdan cuando en las primeras clases quisimos sumar dos n\u00fameros, por ejemplo 2 y 3, y el resultado en lugar de 5 fue 23? Eso ocurri\u00f3 porque, como sabemos, la funci\u00f3n input toma siempre string y en lugar de sumar, lo que hicimos fue concatenar:</p>"},{"location":"colecciones/cadenas/#concatenar","title":"Concatenar","text":"<pre><code># concatenaci\u00f3n\nuna_cadena = \"primera cadena\"\notra_cadena = \"segunda cadena\"\nnueva_cadena = una_cadena + \" - \" + otra_cadena\nprint(nueva_cadena)\n</code></pre> <p>Las strings se pueden pensar como valores comunes (un solo dato) pero tambi\u00e9n pueden ser tratadas como listas (o m\u00e1s apropiadamente como tuplas de caracteres -por ser tambi\u00e9n inmutables-)</p> <p>Por lo tanto, al igual que las listas, se pueden recorrer f\u00e1cilmente con el for</p>"},{"location":"colecciones/cadenas/#recorrer-como-lista","title":"Recorrer (como lista)","text":"<pre><code>nombre = \"Juan\" # recorremos como si fuera esta lista: ['J', 'u', 'a', 'n']\nfor i in range(len(nombre)): # por \u00edndice\n    print(nombre[i])\n\nfor letra in nombre: # lo mismo pero por elemento\n    print(letra)\n</code></pre> <p>Pero... a diferencia de las listas, las strings son inmutables</p> <pre><code>lista = ['m', 'e', 's', 'a']\ncadena = \"mesa\" \nlista[1] = 'i' # Funciona\ncadena[1] = 'i' # NO funciona, no se puede modificar parcialmente\n</code></pre> <p>Como todo objeto en Python, las strings tienen decenas de m\u00e9todos para operar sobre ellas.</p> <p>Por ejemplo, el m\u00e9todo find</p>"},{"location":"colecciones/cadenas/#find-buscar-una-subcadena","title":"Find (buscar una subcadena)","text":"<pre><code>frase = \"Las noches de oto\u00f1o son frescas\"\nposicion = frase.find(\"oto\u00f1o\")  # busca subcadena y devuelve posici\u00f3n\nprint(posicion)\notra_posicion = frase.find(\"s no\")  # no tiene que ser una palabra\nprint(otra_posicion)\nno_existe = frase.find(\"no s\")  # -1 si no existe\nprint(no_existe)\nprint(frase.find(\"es\"))  # encuentra el \"es\" de \"noches\"\nprint(frase.find(\"es\", 10))  # encuentra \"es\" en \"frescas\" (por qu\u00e9?)\n</code></pre> <p>Otro m\u00e9todo muy \u00fatil, split, que sirve para separar:</p>"},{"location":"colecciones/cadenas/#split-convertir-a-lista","title":"Split (convertir a lista)","text":"<pre><code>Separar una cadena con split\nfecha = \"3/5/2022\"\nlista_fecha = fecha.split(\"/\")\nprint(lista_fecha)  # ['3', '5', '2022']\n\nnombres = \"juan---ana---pedro---luisa\"\nprint(nombres.split(\"---\"))  # ['juan', 'ana', 'pedro', 'luisa']\n\ncadena = \"algo otro cosa techo\"\nprint(cadena.split()) # por defecto separa por espacio en blanco\n\"\"\"\n</code></pre>"},{"location":"colecciones/cadenas/#slicing-obtener-una-subcadena","title":"Slicing (obtener una subcadena)","text":"<pre><code># Una operaci\u00f3n muy utilizada (aplica tambi\u00e9n a listas)\nfrase = \"Las noches de oto\u00f1o son frescas\"\nprint(frase[4:10])  # noches\ncomienzo = frase[:3]\nprint(comienzo)  # Las\nfinal = frase[-7:]\nfinal2 = frase[24:]\nprint(final, final2)  # frescas\nprint(frase[-1])\n</code></pre>"},{"location":"colecciones/diccionarios/","title":"Diccionarios","text":"<p>Un diccionario es una variable de almacenamiento m\u00faltiple como una lista, una estructura de datos que sirve para guardar varios datos simult\u00e1neamente. Pero, a diferencia de una lista, cada elemento es un par clave: valor. Por ejemplo, el siguiente diccionario tiene dos elementos, que al igual que en una lista, se separan con una coma.</p> <pre><code>dicci = {'primero': 1, '\u00faltimo': 'two'}\n# El primer elemento del diccionario es ---&gt; 'primero': 1\n# y el segundo es ---&gt; '\u00faltimo': 'two'\n\n# Subindicaci\u00f3n:\n# se realiza con la clave en lugar de una posici\u00f3n como hacemos en las listas\nprint(dicci['\u00faltimo'])  # muestra el valor del segundo elemento\n\nprint(dicci)  # muestra toda el diccionario con las llaves\n\n# len, como en listas, devuelve la cantidad de elementos\nprint(\"Cantidad de elementos del diccionario dicci: \", len(dicci))  \n</code></pre> <p>Declarar y asignar:</p> <pre><code>dicci2 = {}  # diccionario vac\u00edo - Sirve como declaraci\u00f3n\n\n# Agrego o reemplazo:\ndicci2['algo'] = 111  # A diferencia de la lista, esto NO da error\n\nprint(dicci2)\n</code></pre> <p>Borrar y sacar:</p> <pre><code>dicci3 = {'clave1': 'valor1', 'clave2': 'valor2'}\n\ndel(dicci3['clave1']) # elimina\n\nvalor = dicci3.pop('clave2')  # saca el elemento y lo asigna\nprint(dicci3)\nprint(valor)\n</code></pre> <p>Tipos de diccionarios. Si bien desde un punto de vista de su estructura todos los diccionarios son iguales, conceptualmente se pueden distinguir dos tipos:</p> <p>Homog\u00e9neos (tambi\u00e9n llamados colecciones) que son aquellos cuyos elementos son similares</p> <pre><code>remeras = {'lisas': 10, 'rayadas': 5, 'con dibujitos': 3}\n</code></pre> <p>Registro, que son los que tienen elementos complementarios</p> <pre><code>persona = {'nombre': 'Ana', 'edad': 22, 'altura': 1.54}\n</code></pre> <p>Recorridos:</p> <pre><code>persona = {'nombre': 'Ana', 'edad': 22}\n\n# Recorrido por claves solas\nprint('Muestro las claves')\nfor k in persona: # es lo mismo que poner ---&gt; persona.keys()\n    print(k)\n\nprint('Muestro los valores')\nfor v in persona.values(): # Recorrido por valor\n    print(v)\n\nprint('Recorro y muestro por clave y valor')\nfor k, v in persona.items(): # Recorrido por item es clave y valor\n    print(k, \"-&gt;\", v)\n</code></pre> <p>En general, las claves que usaremos ser\u00e1n habitualmente strings, pero los valores podr\u00e1n ser tan complejos como nos haga falta!</p> <pre><code>familia = {\n    \"nombre\": \"Juan\", \n    \"nombres_hijos\": [\"Pedro\", \"Ana\", \"Jos\u00e9\"],\n    \"nombres_padres\": {\"Padre\": \"Juan\", \"Madre\": \"Maria\"}\n}\n\nprint(f\"El nombre de la madre es {familia[\"nombres_padres\"][\"Madre\"]}\")\n\nprint('Nombres de los hijos:')\nfor hijo in familia[\"nombres_hijos\"]:\n    print(hijo)\n</code></pre>"},{"location":"colecciones/listas/","title":"Listas","text":"<p>Las listas (como otros iterables que tiene Python), son variables de almacenamiento m\u00faltiple, es decir, que sirven para guardar varios datos simult\u00e1neamente.</p> <p>Tienen una capacidad de almacenamiento din\u00e1mica (no se requiere ni se necesita un tama\u00f1o predefinido). Adem\u00e1s puede contener valores de cualquier tipo de dato simult\u00e1neamente:</p> <pre><code>cambalache = [9, \"jota\", False, \"\ud83e\udd16\ud83d\udc7d\ud83d\udc0d\", -8.2]\n\nprint(cambalache[1])  # muestra el segundo elemento (el primero est\u00e1 en posici\u00f3n cero)\n\nprint(cambalache)  # muestra toda la lista con los corchetes\n\n# len es una funci\u00f3n que devuelve la cantidad de elementos de la lista\nprint(\"Cantidad de elementos de la lista cambalache: \", len(cambalache))  \n</code></pre> <p>Ahora declaro, asigno y reemplazo:</p> <pre><code>otra_lista = []  # lista vac\u00eda - Sirve como declaraci\u00f3n\n\notra_lista[0] = 111  # IndexError: list assignment index out of range\n# No funcion\u00f3 porque la posici\u00f3n cero a\u00fan no existe\n\notra_lista = [\"q\"] # asigno\nprint(otra_lista)\n\notra_lista[0] = 111  # reemplazo (ahora funciona porque la posici\u00f3n cero ya ten\u00eda valor)\nprint(otra_lista)\n</code></pre> <p>Y finalmente agrego, inserto, saco y borro</p> <pre><code>otra_lista_ mas = []\notra_lista_ mas.append(\"primero\") # agrego\nprint(otra_lista_ mas)\n\notra_lista_ mas.append(\"segundo\") # agrego otro valor al fondo\nprint(otra_lista_ mas)\n\notra_lista_ mas.insert(1, \"al medio\") # inserto en la posici\u00f3n 1\nprint(otra_lista_ mas)\n\notra_lista_ mas[1] = \"reemplazo al que estaba al medio\"\nprint(otra_lista_ mas)\n\notra_lista_ mas.pop(1)  # elimina por posici\u00f3n, por defecto el \u00faltimo\nprint(otra_lista_ mas)\n\notra_lista_ mas.remove(\"primero\")  # elimina por valor\nprint(otra_lista_ mas)\n\notra_lista_ mas = [100, 200, 300, 400, 500]\ndel otra_lista_ mas[1:3] # borra por \u00edndice o por slice\nprint(otra_lista_ mas)\n</code></pre> <p>Se pueden recorrer f\u00e1cilmente con el for</p> <pre><code>muebles = [\"mesa\", \"silla\", \"banquito\"]\n#Se llevan bien con la instrucci\u00f3n de bucle for\n\nprint(\"Recorrido por posici\u00f3n en la lista (con rango)\")\nfor indice in range(len(muebles)): \n    print(muebles[indice])\nprint(\"-----------------------------------------------\")\n\nprint(\"Recorrido por elemento\")\nfor mueble in muebles:\n    print(mueble)\nprint(\"-----------------------------------------------\")\n\nprint(\"Recorrido por elemento con enumeraci\u00f3n\")\n# Equivalente a los dos anteriores juntos, \n# m\u00e1s la posibilidad de empezar a contar desde 1\n# o cualquier otro valor entero\nfor indice, elemento in enumerate(muebles, start=1):\n    print(indice, elemento)\nprint(\"-----------------------------------------------\")\n</code></pre> <p>Carga de lista con iteraci\u00f3n</p> <pre><code>print('Carga de elementos dentro de un for')\nnombres = []\nfor i in range(5):\n    nombre = input(\"Ingrese un nombre: \") # lo pisa en cada vuelta ...\n    nombres.append(nombre) # ... pero lo guarda en la lista\nprint(nombres)\n</code></pre> <p>Listas pararelas</p> <pre><code>nombres = [\"Juan\", \"Ana\", \"Luis\"]  # misma posici\u00f3n, misma persona\nedades = [32, 87, 12]  # entonces Juan tiene 32 a\u00f1os\n\nfor i in range(len(nombres)):\n    # a mismo \u00edndice, datos relacionados\n    print(nombres[i], 'tiene', edades[i], 'a\u00f1os')\n</code></pre> <p>Listas anidadas</p> <pre><code>personas = [[\"Juan\", 32], [\"Ana\", 87], [\"Luis\", 12]]  # equivalente a paralelas\nfor persona in personas: # recorro por elemento\n    print(persona[0], 'tiene', persona[1], 'a\u00f1os', end=' | ')\nprint()\n\nlista_anidada = [\n    ['cero-cero', 'cero-uno'],\n    ['uno-cero', 'uno-uno'],\n    ['dos-cero', 'dos-uno'],\n    ['tres-cero', 'tres-uno']\n    ]\n\n# for anidados por \u00edndice\nfor x in range(len(lista_anidada)):\n    for y in range(len(lista_anidada[x])):\n        print(lista_anidada[x][y], end=' | ')\n</code></pre> <p>Existe un elemento en la lista? Y si est\u00e1.... d\u00f3nde est\u00e1?</p> <pre><code>print('Saber si un valor est\u00e1 en una lista y tambi\u00e9n en que posici\u00f3n est\u00e1')\nnumeros = [20, 10, 30]\n\nif 10 in numeros:\n    print(f'est\u00e1 el 10 en la posici\u00f3n {numeros.index(10)}')\nelse:\n    print('no encontr\u00e9 el n\u00famero 10')\n</code></pre>"},{"location":"flujos/","title":"Flujos de Ejecuci\u00f3n","text":"<p>En la Programaci\u00f3n Estructurada existen 3 flujos de ejecuci\u00f3n:</p> <ol> <li>Secuencia: El programa se ejecuta l\u00ednea por l\u00ednea</li> <li>Alternativa: La ejecuci\u00f3n se bifurca seg\u00fan el valor de verdad de una expresi\u00f3n</li> <li>Iteraci\u00f3n: Se produce un bucle de ejecuci\u00f3n (un fragmento de c\u00f3digo se repite)</li> </ol> <p>El 1 es el m\u00e1s simple e intuitivo. El programa se va ejecutando l\u00ednea a l\u00ednea de arriba hacia abajo.</p> <p>Los flujos 2 y 3 se manejan con estructuras de control gestionadas por instrucciones del lenguaje( if, for, while )</p>"},{"location":"flujos/if/","title":"If","text":"<p>Adem\u00e1s del flujo de ejecuci\u00f3n secuencial (que significa que se va ejecutando una l\u00ednea de programa de arriba hacia abajo, una tras otra), en la programaci\u00f3n estructurada tenemos flujo alternativo y flujo repetitivo.</p> <p>En Python la alternativa se maneja con la instrucci\u00f3n if y sus instrucciones complementarios elif y else.</p> <p>La alternativa significa que no necesariamente se ejecutan todas las l\u00edneas del programa. Puede ocurrir que se \"salteen\" l\u00edneas dependiendo de una condici\u00f3n.</p> <pre><code>n = 1\nif n &gt; 2: # condici\u00f3n: expresi\u00f3n con un valor de verdad \n    print('la siguiente l\u00ednea se ejecuta si la condici\u00f3n es verdadera')\n    print(\"es mayor que 2\") # en este caso, esto NO se ejecuta\nelse: # si no se cumple la condici\u00f3n del if\n    print(\"no es mayor que 2\")\nprint('fin') # esta l\u00ednea se ejecuta siempre porque estoy \"fuera\" del if\n</code></pre> <p>Observemos tambi\u00e9n, que la o las l\u00edneas que dependen del if o del else est\u00e1n indentadas, tienen una sangr\u00eda, no est\u00e1n en la misma columna sino corridas varios espacios hacia la derecha (la cantidad de espacios no importa pero siempre tiene que ser la misma en un programa).</p>"},{"location":"flujos/if/#operadores-de-comparacion-y-logicos","title":"Operadores de Comparaci\u00f3n y L\u00f3gicos","text":"<p>Para que una condici\u00f3n tenga valor de verdad usaremos operadores de comparaci\u00f3n y l\u00f3gicos:</p> <p>== (igual), != (distinto), &gt;, &lt;, &gt;=, &lt;= y operadores l\u00f3gicos (and, or, not)</p> <pre><code>edad = 77\nif edad &lt; 12: # el \u00fanico if\n    print(\"es un ni\u00f1o\")\nelif 13 &lt;= edad &lt;= 19: # esto es equivalente a edad &gt;= 13 and edad &lt;= 19\n    print(\"es un adolescente\")\nelif 20 &lt;= edad &lt;= 70: # puede haber m\u00e1s de un elif\n    print(\"es un adulto\")\nelse: # el \u00fanico else para toda opci\u00f3n no contemplada anteriormente\n    print(\"es un adulto mayor\")\n</code></pre> <p>Aprovechamos para introducir el tipo de dato l\u00f3gico o booleano. Las variables booleanas solamente pueden contener dos valores True (verdadero) False (falso). Repasamos los tipos de datos con estas variables:</p> <pre><code>nombre = 'Pablo' # string (cadena de caracteres) -&gt; str\nedad = 59 # integer (entero) -&gt; int\naltura = 1.73 # floating point (real) -&gt; float\nes_alto = False # boolean (l\u00f3gico) -&gt; bool\nes_viejo = True # boolean (l\u00f3gico) -&gt; bool\n</code></pre> <p>Las variables booleanas tienen valor de verdad en si mismas, no es necesario compararlas:</p> <pre><code>if es_viejo: # esto es lo mismo que poner: if es_viejo == True\n    print(nombre, 'es viejo')\n\nif edad &gt;= 18 and not es_alto:\n    print('Es mayor de edad y es bajo')\n</code></pre>"},{"location":"flujos/bucles/","title":"Bucles","text":"<p>Un bucle (loop en ingl\u00e9s), es un proceso iterativo que ocurre durante la ejecuci\u00f3n del programa.</p> <p>Iteraci\u00f3n es un concepto parecido a repetici\u00f3n pero no es un sin\u00f3nimo exacto porque en la iteraci\u00f3n, cada vez que se reinicia el proceso, puede haber cambios parciales en la ejecuci\u00f3n (cambio de estado).</p> <p>Lo iremos viendo en la pr\u00e1ctica! </p> <p>Un bucle es controlado por una instrucci\u00f3n del lenguaje. </p> <p>En Python hay dos instrucciones que veremos a continuaci\u00f3n: for y while</p> <p>El bucle for se utiliza principalmente para procesos de un n\u00famero determinado de iteraciones.</p> <p>El bucle while, se usa habitualmente para realizar procesos de una cantidad indeterminada de iteraciones.</p> <p>Vamos a verlos en detalle:</p>"},{"location":"flujos/bucles/#bucles-for-y-while","title":"Bucles for y while","text":""},{"location":"flujos/bucles/for%20copy/","title":"Bucle for","text":"<p>Para la sintaxis del for, hay que tener en cuenta dos requisitos: 1. Al final de la l\u00ednea tienen que poner el signo de dos puntos (:) 2. El bloque de c\u00f3digo (una o m\u00e1s l\u00edneas que dependen del for) DEBE estar indentado</p> <p>Con los ejemplos siguientes empezaremos a entenderlo:</p>"},{"location":"flujos/bucles/for%20copy/#recorrido-con-rango","title":"Recorrido con rango","text":"<p>Ejemplo #1: <pre><code>for _ in range(3):\n    print(\"hola\")\n</code></pre> hola hola hola</p> <p>Este ejemplo es un proceso repetitivo que se mueve en un rango 3.  Qu\u00e9 significa eso? que lo que est\u00e1 adentro del for (se dice as\u00ed cuando una o varias l\u00edneas del programa est\u00e1n indentadas, es decir, con una especie de sangr\u00eda: NO comienzan justo debajo del for, sino algunas columnas m\u00e1s a la derecha).</p> <p>Entonces, lo que depende del for (lo que est\u00e1 adentro), se ejecutar\u00e1 seg\u00fan lo que se defina all\u00ed, en este primer caso, la repetici\u00f3n del print(\"hola\"). </p> <p>El range(3) est\u00e1 diciendo que dicha repetici\u00f3n se har\u00e1 3 veces.</p> <p>Ejemplo #2: <pre><code>for numero in range(5):\n    print(numero)\n</code></pre> 0 1 2 3 4</p> <p>En este segundo caso, habr\u00e1 5 iteraciones, que a diferencia del Ejemplo 1 no ser\u00e1n repeticiones estrictas, en cambio, el valor de la variable numero se ir\u00e1 incrementando en cada vuelta del for.</p> <p>En ambos ejemplos, el range() recibe un solo valor (stop), y en estos casos, comienza desde 0 (cero) y el bucle da tantas vueltas como especifica el dicho stop, es decir, llega hasta el valor menos 1. En nuestro Ejemplo 2, como el rango es 5, el bucle se ejecuta 5 veces y, al comenzar desde 0 el \u00faltimo valor no es 5, sino 4.</p>"},{"location":"flujos/bucles/for%20copy/#recorrido-por-elemento","title":"Recorrido por elemento","text":"<p>Para seguir aprendiendo sobre el bucle for, seguimos en Listas</p>"},{"location":"flujos/bucles/for/","title":"Bucle for","text":"<p>Para la sintaxis del for, hay que tener en cuenta dos requisitos: 1. Al final de la l\u00ednea tienen que poner el signo de dos puntos (:) 2. El bloque de c\u00f3digo (una o m\u00e1s l\u00edneas que dependen del for) DEBE estar indentado</p> <p>Con los ejemplos siguientes empezaremos a entenderlo:</p>"},{"location":"flujos/bucles/for/#recorrido-con-rango","title":"Recorrido con rango","text":"<p><pre><code>for _ in range(3):\n    print(\"hola\")\n</code></pre> hola hola hola</p> <p>Este ejemplo es un proceso repetitivo que se mueve en un rango 3.  Qu\u00e9 significa eso? que lo que est\u00e1 adentro del for (se dice as\u00ed cuando una o varias l\u00edneas del programa est\u00e1n indentadas, es decir, con una especie de sangr\u00eda: NO comienzan justo debajo del for, sino algunas columnas m\u00e1s a la derecha).</p> <p>Entonces, lo que depende del for (lo que est\u00e1 adentro), se ejecutar\u00e1 seg\u00fan lo que se defina all\u00ed, en este primer caso, la repetici\u00f3n del print(\"hola\"). </p> <p>El range(3) est\u00e1 diciendo que dicha repetici\u00f3n se har\u00e1 3 veces.</p> <pre><code>for numero in range(5):\n    print(numero)\n</code></pre> <p>0 1 2 3 4</p> <p>En este segundo caso, habr\u00e1 5 iteraciones, que a diferencia del Ejemplo 1 no ser\u00e1n repeticiones estrictas, en cambio, el valor de la variable numero se ir\u00e1 incrementando en cada vuelta del for.</p> <p>En ambos ejemplos, el range() recibe un solo valor (stop), y en estos casos, comienza desde 0 (cero) y el bucle da tantas vueltas como se especifica, es decir, llega hasta el valor menos 1. En nuestro Ejemplo 2, como el rango es 5, el bucle se ejecuta 5 veces y, al comenzar desde 0 el \u00faltimo valor no es 5, sino 4.</p> <p>Sintaxis (formato) m\u00e1s general:</p> <pre><code>valor_inicial = 5\nvalor_final = 9\n\nprint('El for comienza con la variable_de_recorrido tomando el valor_inicial')\n\nfor variable_de_recorrido in range(valor_inicial, valor_final):\n    # muestra 5 cuando ingresa y luego 6, 7 y 8\n    print(variable_de_recorrido) \n\nprint('cuando llega al valor final menos uno sale')\n</code></pre> <p>Cuando el valor inicial es cero (como en los ejemplos iniciales) no hace falta colocarlo.</p> <p>Las instrucciones de control de flujo como if y for se pueden anidar, es decir, poner una dentro de otra.</p> <pre><code>for i in range(10):\n    if i &gt; 7:\n        print(i)\n</code></pre> <p>Cualquier expresi\u00f3n cuyo resultado sea un entero se puede poner como valor inicial o valor final.</p> <pre><code>vi = 10 # valor inicial\nvf = 20 # valor final\n\nprint('rango con expresiones:')\n\nfor i in range(vi-15, vf*2//3):\n    print(i, end=' | ')\n</code></pre> <p>Importante!</p> <p>Prueben estos fragmento de c\u00f3digo y experimenten modificando los valores!</p>"},{"location":"flujos/bucles/for/#recorrido-por-elemento","title":"Recorrido por elemento","text":"<p>Para seguir aprendiendo sobre el bucle for, seguimos en Listas (pr\u00f3ximamente)</p>"},{"location":"flujos/bucles/while/","title":"Bucle while","text":"<p>Para la sintaxis del while, hay que tener en cuenta estos requisitos:  </p> <ol> <li> <p>Luego de la palabra reservada while, debe haber una expresi\u00f3n que tenga un valor de verdad. El bucle se repetir\u00e1 mientras dicha expresi\u00f3n sea verdadera.</p> </li> <li> <p>Al final de la l\u00ednea tienen que poner el signo de dos puntos (:)  </p> </li> <li> <p>El bloque de c\u00f3digo (una o m\u00e1s l\u00edneas que dependen del while) DEBE estar indentado</p> </li> </ol> <p>Con los ejemplos siguientes lo comenzaremos a entender:</p>"},{"location":"flujos/bucles/while/#recorrido-que-depende-de-la-respuesta-del-usuario","title":"Recorrido que depende de la respuesta del usuario","text":"<p>Ejemplo: <pre><code>respuesta = \"si\" # esto asegura que va a ingresar\nwhile respuesta == \"si\": # mientras la variable respuesta siga valiendo \"si\"\n    nombre = input(\"Ingrese su nombre: \")\n    print(\"Hola\", nombre)\n    # La siguiente pregunta sirve para saber si quiere continuar o no\n    respuesta = input(\"Quiere saludar a m\u00e1s personas? (si/no): \")\nprint('Adi\u00f3s! (Sali\u00f3 del while porque dej\u00f3 de contestar \"si\")')\n</code></pre></p> <p>Lo que est\u00e1 adentro del while (se dice as\u00ed cuando una o varias l\u00edneas del programa est\u00e1n indentadas, es decir, con una especie de sangr\u00eda: NO comienzan justo debajo del while, sino algunas columnas m\u00e1s a la derecha).</p> <p>Entonces, lo que depende del while (lo que est\u00e1 adentro), se ejecutar\u00e1 MIENTRAS la condici\u00f3n sea verdadera (una cantidad indefinida de veces, porque depende del momento en el que el usuario decide volver falsa la expresi\u00f3n). </p>"},{"location":"flujos/bucles/while/#recorrido-que-depende-de-una-condicion-sin-interaccion","title":"Recorrido que depende de una condici\u00f3n sin interacci\u00f3n","text":"<p>Ejemplo: <pre><code>n = 0\nwhile n &lt; 5:\n    print(\"dentro del while\")\n    n = n + 1  # contador\n    print(n)\n    if n == 3:\n        print(\"lleg\u00f3 el 3!!!!\")\nprint(\"afuera del while porque dej\u00f3 de cumplirse la condici\u00f3n\")\n</code></pre> Aqu\u00ed este while est\u00e1 funcionando como una imitaci\u00f3n de un for, la diferencia es que el for incrementa la variable de recorrido autom\u00e1ticamente y en el while la tenemos que incrementar \"a mano\" con un contador.</p>"},{"location":"flujos/bucles/while/#contadores-y-acumuladores","title":"Contadores y Acumuladores","text":"<pre><code>contador_envios = 0\nacumulador_cajas = 0\n\nrespuesta = 's'\nwhile respuesta == 's':\n    contador_envios = contador_envios + 1\n    # la l\u00ednea anterior se puede escribir tambi\u00e9n asi: contador_envios += 1\n    print(f'Env\u00edo #{contador_envios}')\n    cantidad_cajas = input('Cu\u00e1ntas cajas llegaron? ')\n    cantidad_cajas = int(cantidad_cajas)\n    acumulador_cajas = acumulador_cajas + cantidad_cajas\n    # igual que el contador, tambi\u00e9n se puede escribir asi: \n    # acumulador_cajas += cantidad_cajas\n    respuesta = input('LLegaron m\u00e1s cajas? (s/n): ')\n\nprint(f'En {contador_envios} env\u00edos fueron recibidas {acumulador_cajas} cajas')\n</code></pre>"},{"location":"funciones/","title":"Funciones","text":"<p>Buenas pr\u00e1cticas!</p> <p>Las funciones permiten modularizar un programa, dividi\u00e9ndolo en porciones m\u00e1s comprensibles y simples de mantener. Son una herramienta imprescindible para la programaci\u00f3n limpia!</p> <p>Las funciones en Python se pueden considerar de dos tipos:  </p> <ol> <li> <p>Subprogramas o procedimientos: Son fragmentos de c\u00f3digo que realizan una tarea sin necesidad de devolver ning\u00fan dato. Suelen ser de un solo uso y su finalidad es dividir el programa en componentes m\u00e1s peque\u00f1os y m\u00e1s f\u00e1cilmente depurables y legibles. Ejemplos: funci\u00f3n de carga, funci\u00f3n de salida, hacer una l\u00ednea separadora, etc.</p> </li> <li> <p>Funciones propiamente dichas: Son fragmentos de c\u00f3digo que normalmente reciben y devuelven datos y que adem\u00e1s se pueden reutilizar. Aqu\u00ed dividiremos entre funciones con parametrizaci\u00f3n b\u00e1sica y funciones con parametrizaci\u00f3n avanzada. </p> </li> </ol> <p>De cualquier manera, en t\u00e9rminos pr\u00e1cticos, vamos a dividir el tratamiento entre funciones b\u00e1sicas (procedimientos y funciones con par\u00e1metros simples) y funciones con parametrizaci\u00f3n avanzada (posicionales, clave-valor, tuplas, diccionarios).</p> <p>Importante!</p> <p>Las funciones deben ser independientes: todo objeto usado dentro de ellas tiene que ser un par\u00e1metro o una variable local (aquellas que solamente existen al interior de la funci\u00f3n). NO hay que usar variables globales (las del programa principal) dentro del bloque de la funci\u00f3n. Esta independencia nos permitir\u00e1 la reutilizaci\u00f3n de las funciones no solamente en el mismo programa sino tambi\u00e9n en otros.</p>"},{"location":"funciones/#vamos-a-verlas-en-detalle-","title":"Vamos a verlas en detalle -&gt;","text":""},{"location":"funciones/#funciones-basicas-y-parametrizacion-avanzada","title":"Funciones b\u00e1sicas y parametrizaci\u00f3n avanzada","text":""},{"location":"funciones/func_av/","title":"Funciones con parametrizaci\u00f3n avanzada","text":""},{"location":"funciones/func_av/#orden-recomendado","title":"Orden recomendado","text":"<ol> <li>Posicionales individuales. Par\u00e1metro posicional &lt;-&gt; Argumento posicional obligatorio</li> <li>*args. Tupla de tama\u00f1o indeterminado de posicionales. No tiene argumentos obligatorios. Positional-only</li> <li>Pares clave-valor o con valor por defecto individuales. Par\u00e1metro con valor por defecto &lt;-&gt; Argumento opcional</li> <li>**kwargs. Diccionario de tama\u00f1o indeterminado de pares clave-valor. No tiene argumentos obligatorios. Keyword-only</li> </ol> <p>variantes individuales exclusivas (positional-only y keyword-only). Dependen de los seudo-par\u00e1metros / y *</p> <pre><code>def foo1(a, b, *args, n1=\"ene uno\", **kwargs):\n    print('foo1')\n    print(a, b, args, n1, kwargs)\nfoo1(1, 2, 3, 4, 5, xX=\"equisequis\", n1=\"&lt;nuevo ene uno&gt;\", nN=\"algo\")\nfoo1(\"a\", \"b\") # los \u00fanicos argumentos obligatorios son los que corresponde a par\u00e1metros posicionales\n</code></pre> <pre><code># funciona pero no es recomendable porque dificulta la percepci\u00f3n del orden\ndef foo2(a, b, n1=\"ene uno\", *args, **kwargs):\n    print('foo2')\n    print(a, b, args, n1, kwargs)\nfoo2(1, 2, 3, 4, 5, k='k')\n</code></pre> <pre><code># variante posicionales exclusivos (positional-only arguments)\ndef foo3(a, b, /, c): \n    print('foo3')\n    # la / obliga a NO usar el nombre del par\u00e1metro \n    #de los que quedan a la izquierda\n    print(a, b, c)\nfoo3(1, 2, c=3) # solamente funciona si NO se pone a= y b=\n</code></pre> <pre><code># variante clave-valor exclusivos (keyword-only arguments)\ndef foo4(a=1, b=2, *, c=3, d=4): \n    print('foo4')\n    # el * obliga a usar el nombre del par\u00e1metro\n    # de los que quedan a la derecha\n    print(a, b, c, d)\nfoo4(11, 22, c=33, d=44) # solamente funciona si se ponen c= y d=\n</code></pre>"},{"location":"funciones/func_base/","title":"Funciones b\u00e1sicas","text":"<pre><code>def raya():\n    print(\"----------------------------\")\n</code></pre> <p>Una funci\u00f3n debe declararse con la palabra reservada def, luego un nombre (mismo criterio de nombrado que las variables), y luego el bloque de c\u00f3digo que pertenece a la funci\u00f3n (son todas las l\u00edneas que est\u00e9n indentadas).</p> <pre><code># funci\u00f3n como procedimiento\ndef raya():\n    print(\"----------------------------\")\n\nprint(\"Ahora viene una raya:\")\nraya()\nprint(\"Y ahora otra raya m\u00e1s:\")\nraya()\n</code></pre> <p>Una funci\u00f3n que no retorna valor (un procedimiento) se ejecuta (se dice tambi\u00e9n que se \"llama\" a la funci\u00f3n, en ingl\u00e9s, que se hace un \"call\") poniendo su nombre y sus par\u00e9ntesis. Puede ejecutarse m\u00e1s de una vez.</p> <pre><code># funci\u00f3n propiamente dicha\ndef bar():\n    return 'valor que devuelve'\n</code></pre> <p>Una funci\u00f3n que tiene return devuelve el o los valores que tiene a continuaci\u00f3n, y se la llama para ser asignada (a una variable) o bien operada (como si ya fuera una variable) o directamente printeada:</p> <pre><code>print (bar()) # muestra 'valor que devuelve'\nvalor_devuelto = bar() # asigna la string a la variable\n</code></pre>"},{"location":"funciones/func_base/#parametros","title":"Par\u00e1metros","text":"<p>Si se quiere flexibilizar el comportamiento de la funci\u00f3n y de esa manera darle mayor utilidad, se debe hacerlo definiendo par\u00e1metros, que son variables que se colocan entre los par\u00e9ntesis en la definici\u00f3n de la funci\u00f3n. Dichos par\u00e1metros ser\u00e1n reemplazan por argumentos enviados durante la ejecuci\u00f3n. Veamos un ejemplo:</p> <p>Supongamos que nos parece que nuestra funci\u00f3n raya es muy limitada (tiene una cantidad fija de caracteres y adem\u00e1s son solamente guiones). La vamos a hacer m\u00e1s flexible:</p> <p>Primero, vamos a hacer una modificaci\u00f3n para que luego se vea bien el efecto de los par\u00e1metros</p> <pre><code>def raya():\n    for x in range(20): \n        print(\"-\", end=\"\")\n\nraya()\n</code></pre> <p>Hacemos un bucle de 20 vueltas, por tanto mostraremos 20 guiones (el end=\"\" es para que no salte de l\u00ednea)</p> <pre><code>def raya(cantidad, caracter): # par\u00e1metros: cantidad, caracter\n    for x in range(cantidad): \n        print(caracter, end=\"\")\n    print()\n\nraya(20, \"-\") # argumentos: 20, \"-\" # reemplazan a los par\u00e1metros \nraya(10, \"+\") # argumentos: 10, \"+\" # 10 reemplaza a cantidad y + a caracter\nraya(30, \"$\") # argumentos: 30, \"$\"\n\n# Salida:\n\"\"\" Las 3 comillas son otra forma de comentario para multil\u00edneas\n--------------------\n++++++++++\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n\"\"\"\n</code></pre> <p>Como vemos, al enviar argumentos diferentes, la raya var\u00eda su largo y su caracter. Estos par\u00e1metros se denominan posicionales y cuando usamos la funci\u00f3n, los valores que enviamos se llaman argumentos, son obligatorios y ocupan el lugar de los par\u00e1metros en la ejecuci\u00f3n.</p>"},{"location":"funciones/func_base/#retorno","title":"Retorno","text":"<p>Ahora veremos el retorno de datos desde la funci\u00f3n.</p> <p>Hasta ahora, estamos usando la funci\u00f3n como un subprograma, veamos otro ejemplo y luego lo convertimos en una funci\u00f3n propiamente dicha.</p> <pre><code>def saludo(nombre):\n    print(\"Hola\", nombre)\n\nsaludo(\"Ana\")\n</code></pre> <p>Tenemos aqu\u00ed una funci\u00f3n tipo procedimiento, que tiene un par\u00e1metro nombre y cuando recibe el argumento \"Ana\" produce el saludo: Hola Ana. Vemos como la llamada a la funci\u00f3n, cuando ponemos el nombre y se ejecuta, es similar al ejemplo anterior de la raya.</p> <p>Ahora haremos la modificaci\u00f3n de sustituir la funci\u00f3n print() por la instrucci\u00f3n return.</p> <pre><code>def saludo(nombre):\n    return \"Hola \" + nombre # el signo + entre dos strings las concatena\n\nprint(saludo(\"Ana\"))\n</code></pre> <p>Vemos que aqu\u00ed, al agregar el retorno, el saludo vuelve en el nombre de la funci\u00f3n, es por eso que podemos y tenemos que hacer el print() para poder obtener la salida deseada.</p> <p>Otro ejemplo:</p> <pre><code>def doble(numero):\n    print(numero*2)\n\ndoble(3)\n</code></pre> <p>Si en cambio, queremos que el valor doble del argumento enviado sea retornado, debemos printear la funci\u00f3n (o bien asignarla o tambi\u00e9n operarla):</p> <pre><code>def doble(numero):\n    return numero*2\n\nprint(doble(3))\nprint(f'El doble del doble es {doble(4) * 2}')\ndoble_de_9 = doble(9)\nprint(doble_de_9)\n</code></pre> <p>Los par\u00e1metros posicionales obligatorios (los m\u00e1s b\u00e1sicos que estamos viendo hasta aqu\u00ed), deben respetar cantidad, orden y tipo de dato a la hora de enviarle los argumentos a la funci\u00f3n, independientemente de que le enviemos variables, literales o incluso expresiones.</p> <pre><code>def operar(operacion, n1, n2): # 3 par\u00e1metros: string, n\u00famero, n\u00famero\n    if operacion == 'suma':\n        resultado = n1 + n2 # resultado es una variable local\n    elif operacion == 'resta':\n        resultado = n1 - n2 \n    else:\n        resultado = f'Operaci\u00f3n desconocida \"{operacion}\"'\n    return resultado\n\nprint(resultado) # error!!! esta variable solamente existe dentro de la funci\u00f3n\nprint('Resultado de la suma de 4+5: ', end='')\nprint(operar(\"suma\", 4, 5)) # mismo orden que los par\u00e1metros\na = 2\nb = 3\nprint(f'{a=} y {b=}')\nprint('Resultado de la resta:', operar(\"resta\", a, b))\nsalida = operar('mutiplicaci\u00f3n', 10, 4) # asigno el retorno a una variable\nprint(salida)\nprint(f'a * 3 + 10 (a vale 2): {operar('suma', a*3, 10)}')\notra_salida = operar(7, 5, 'resta') # error!!! orden incorrecto\nprint(operar('suma', 1, 2, 3)) # error!!! cantidad incorrecta de argumentos\n</code></pre>"},{"location":"funciones/index%20copy/","title":"Funciones","text":"<p>Buenas pr\u00e1cticas! </p> <p>Las funciones permiten modularizar un programa, dividi\u00e9ndolo en porciones m\u00e1s comprensibles y simples de mantener. Son una herramienta imprescindible para la programaci\u00f3n limpia!</p> <p>Las funciones en Python se pueden considerar de dos tipos:  </p> <ol> <li> <p>Subprogramas o procedimientos: Son fragmentos de c\u00f3digo que realizan una tarea sin necesidad de devolver ning\u00fan dato. Suelen ser de un solo uso y su finalidad es dividir el programa en componentes m\u00e1s peque\u00f1os y m\u00e1s f\u00e1cilmente depurables y legibles. Ejemplos: funci\u00f3n de carga, funci\u00f3n de salida, hacer una l\u00ednea separadora, etc.</p> </li> <li> <p>Funciones propiamente dichas: Son fragmentos de c\u00f3digo que normalmente reciben y devuelven datos y que adem\u00e1s se pueden reutilizar. Aqu\u00ed dividiremos entre funciones con parametrizaci\u00f3n b\u00e1sica y funciones con parametrizaci\u00f3n avanzada. </p> </li> </ol> <p>De cualquier manera, en t\u00e9rminos pr\u00e1cticos, vamos a dividir el tratamiento entre funciones b\u00e1sicas (procedimientos y funciones con par\u00e1metros simples) y funciones con parametrizaci\u00f3n avanzada (posicionales, clave-valor, tuplas, diccionarios).</p> <p>** IMPORTANTE ** --&gt; Las funciones deben ser independientes: todo objeto usado dentro de ellas tiene que ser un par\u00e1metro o una variable local (aquellas que solamente existen al interior de la funci\u00f3n). NO hay que usar variables globales (las del programa principal) dentro del bloque de la funci\u00f3n. Esta independencia nos permitir\u00e1 la reutilizaci\u00f3n de las funciones no solamente en el mismo programa sino tambi\u00e9n en otros.</p>"},{"location":"funciones/index%20copy/#vamos-a-verlas-en-detalle","title":"Vamos a verlas en detalle:","text":""},{"location":"funciones/index%20copy/#funciones-basicas-y-parametrizacion-avanzada","title":"Funciones b\u00e1sicas y parametrizaci\u00f3n avanzada","text":""},{"location":"inicio/","title":"Comienzo r\u00e1pido","text":""},{"location":"inicio/#estructura-de-carpetas-arbol-de-directorios","title":"Estructura de carpetas (\u00c1rbol de directorios)","text":"<p>En Linux, oprimiendo la tecla Windows (en Linux le decimos SUPER) podemos acceder a todas las aplicaciones. Si hemos instalado Linux Mint, adem\u00e1s tendremos un panel inferior donde veremos varias aplicaciones entre ellas el Explorador de Archivos y la Terminal.</p> Panel Principal <p>Cuando abrimos el Explorador de Archivos (Files) o bien ejecutamos una terminal (tambi\u00e9n llamada consola), nos encontramos parados en nuestro directorio (o carpeta) base. Para cada usuario, su directorio base ser\u00e1 /home/nombre_usuario. </p> <p>En mi caso ser\u00e1 /home/kan/ (ese soy yo), y si vos sos Ana ser\u00e1 /home/ana/ y si sos Pedro ser\u00e1 /home/pedro/</p> Explorador de Archivos Terminal <p>Como se puede observar, en ambas aplicaciones veremos lo mismo: varias carpetas est\u00e1ndar como Documentos, Im\u00e1genes, etc.</p> <p>Para armar la estructura m\u00ednima requerida para empezar, lo podemos hacer como seguramente sabemos, usando el Explorador de Archivos o bien la terminal. El resultado ser\u00e1 el mismo.</p> <p>La idea es que nos vayamos familiarizando con la terminal que es la herramienta habitual de todo Desarrollador.</p> <p>Para dejar todo listo, crearemos una carpeta de nombre itec y dentro de ella otra carpeta de nombre programacion1.</p> <p>Los siguientes comandos realizan esas acciones, con mkdir creamos un directorio y con cd entramos all\u00ed. Pod\u00e9s copiar y pegar o escribir estos comandos en tu terminal y apretar la tecla Enter <pre><code>mkdir itec\ncd itec\nmkdir programacion1\ncd programacion1\n</code></pre></p> <p>Importante!</p> <p>Solamente letras min\u00fasculas del alfabeto est\u00e1ndar -sin letras acentuadas ni e\u00f1e-, n\u00fameros y el caracter gui\u00f3n bajo para nombrar carpetas y archivos de programa. Si est\u00e1s tentado a ponerle a una carpeta, por ejemplo:</p> <p>Materia Programaci\u00f3n 1 de Primer A\u00f1o, NO LO HAGAS, </p> <p>en cambio ponele, por ejemplo:</p> <p>programacion1 o prog_1 (nombres de carpetas bien de programador \ud83d\ude0f)</p>"},{"location":"inicio/#vamos-ahora-a-prepararnos-para-programar","title":"Vamos ahora a prepararnos para programar!","text":"<p>Apenas se ingresa en el Editor de Texto, lo primero que hacemos es guardarlo, de ese modo le podemos poner un nombre y ubicarlo en la carpeta que hemos creado. Eso lo hacemos con la combinaci\u00f3n de teclas  Ctrl-S. Se nos abrir\u00e1 una ventana y all\u00ed ingresaremos en el directorio itec y luego en programacion1. Le ponemos de nombre hola_mundo.py y lo guardamos.</p> <p>Si cerramos la ventana del archivo (NO la del editor), igualmente podemos abrir uno nuevo con Ctrl-N para luego repetir lo anterior, o sea grabarlo y asignarle un nombre. Verificar que tenga la extensi\u00f3n .py para que el editor reconozca que ser\u00e1 un programa en Python y luego pueda ser ejecutado apropiadamente en la terminal.</p>"},{"location":"inicio/#escribamos-nuestro-primer-programa","title":"Escribamos nuestro primer programa!","text":"<p>Copiar y pegar en el editor:</p> <p><pre><code>   print(\"hola mundo\")\n</code></pre> No olvidar grabar: Ctrl-S </p> <p>Ahora vamos a ejecutar el programa (en ingl\u00e9s: run the program -por eso los devs acostumbramos decir \"correr el programa\"). Es decir, hacerlo andar para obtener un resultado. Nos vamos a la terminal y escribimos all\u00ed: <pre><code>python3 hola_mundo.py\n</code></pre></p> <p>Si todo est\u00e1 bien deber\u00eda producirse la siguiente salida:</p> <p>hola mundo</p> <p></p> <p>Hemos ejecutado el programa usando el int\u00e9rprete python3 y utilizamos nuestra primera funci\u00f3n.</p> <p>La funci\u00f3n print nos sirve para mostrar datos por la pantalla (Ya seguiremos hablando de ella).</p> <p>Si llegamos con \u00e9xito hasta aqu\u00ed, hemos escrito y ejecutado nuestro primer programa en Python!</p>"},{"location":"inicio/datos/","title":"Tipos de Datos B\u00e1sicos","text":""},{"location":"inicio/datos/#str","title":"str","text":"<p>Todo lo que se escriba encerrado entre comillas (dobles o sencillas) es una cadena de caracteres, en ingl\u00e9s se les llama strings y su tipo de dato es str. <pre><code>\"Esto es una cadena de caracteres\"\n</code></pre> Una string puede estar vac\u00eda o tener un solo caracter o ser muy larga como un libro o una biblioteca entera</p> <pre><code>'En ingl\u00e9s se les llama strings y su tipo de dato es str'\n</code></pre> <p>Para mostrar el contenido de una string por la consola (el \u00e1rea de salida del programa, donde se ve el resultado de su ejecuci\u00f3n), debemos ponerla adentro de los par\u00e9ntesis de la funci\u00f3n print(). <pre><code># Copie y pegue en el editor. Ejecute.\nprint(\"Este texto saldr\u00e1 por la pantalla sin las comillas\")\nprint(\"\") # Esta es una cadena vac\u00eda\n</code></pre></p>"},{"location":"inicio/datos/#int-y-float","title":"int y float","text":"<p>N\u00fameros enteros (sin decimales) y Reales (con decimales)</p> <pre><code># Los dos primeros son enteros y los dos \u00faltimos reales \n# (se usa punto decimal, no la coma)\nprint(3, 27000, 1.73, 0.8)\n</code></pre> <p>Como acabamos de ver, la funci\u00f3n print() puede mostrar varios datos (4 n\u00fameros en el ejemplo anterior). Iremos viendo gradualmente otras formas de mostrar informaci\u00f3n.</p>"},{"location":"inicio/datos/#bool","title":"bool","text":"<p>Valores l\u00f3gicos (booleanos)</p> <pre><code># True (verdadero) y False (falso)\n# Muestro True \ud83d\udc38, tendr\u00e1 sentido cuando veamos variables \n# y sobre todo alternativas!\nprint(True) \n</code></pre>"},{"location":"inicio/operaciones/","title":"Operaciones matem\u00e1ticas","text":"<p>Las variables y las constantes o los valores literales se pueden operar matem\u00e1ticamente.  Los operadores son los siguientes: </p> <p><code>+</code> (suma) <code>-</code>(resta) <code>*</code>(multiplicaci\u00f3n) <code>**</code>(potenciaci\u00f3n) <code>/</code>(divisi\u00f3n) <code>//</code>(divisi\u00f3n entera) <code>%</code>(m\u00f3dulo -resto de la divisi\u00f3n-)</p> <pre><code>print(3 + 5) # muestra 8\nsuma = 3 + 5 # asigna el resultado a la variable suma\nprint(suma)\nprint(3 - 5) # muestra -2\nprint(3 * 5) # muestra 15\nprint(3 / 5) # muestra 0.6\nprint(3 // 5) # muestra 0 porque es divisi\u00f3n entera \nprint(11 % 2) # muestra 1 que es el resto de la divisi\u00f3n entera\nprint(3 ** 5) # muestra 243, 3 elevado a la quinta potencia\n\n# operaciones con variables (se pueden operar de manera combinada variables y literales)\na = 3\nb = 5\nprint(a + b) # sigue dando 8\nsuma = a + 1 # suma vale 4\nprint(suma)\nprint(11 - b) # muestra 6\n\"\"\"\n</code></pre> <p>El resultado de la operaci\u00f3n depende del tipo de dato.</p> <p>Es importante tener en cuenta que SIEMPRE, la funci\u00f3n input(), toma el dato ingresado como str. Es decir que si ingreso un n\u00famero, tengo que convertirlo a int o bien a float para poder operar con ese dato. De no hacerse dicha conversi\u00f3n, cualquier operaci\u00f3n sobre ese n\u00famero ser\u00e1 en realidad una operaci\u00f3n de strings.</p> <pre><code>edad = input(\"Ingrese su edad: \")\nprint(\"El doble de tu edad es\", edad * 2) # ups !\n# claro! input toma string, NO multiplic\u00f3\n# olvid\u00e9 convertir a entero, ahora va:\nedad = int(edad)\n# pruebo de nuevo:\nprint(\"El doble de tu edad es\", edad * 2)\n</code></pre>"},{"location":"inicio/variables/","title":"Variables","text":"<p>Una variable es el nombre de un espacio de almacenamiento de un dato. Dicho dato es un valor que ser\u00e1 de un tipo de dato espec\u00edfico.</p> <p>Para ir clarificando:</p> <p>Si decimos que la variable nombre contiene la string \"Ana\", pues entonces dicha variable ser\u00e1 de tipo str (cadena de caracteres o string).</p> <pre><code># Se asigna el valor a la variable con el signo igual.\nnombre = \"Ana\"\n</code></pre> <p>Si luego decimos que la variable edad contiene el n\u00famero 33, el tipo de datos ser\u00e1 int.</p> <pre><code>edad = 33\n</code></pre> <p>Si finalmente decimos que tenemos una variable altura, cuyo valor es 1.65, aqu\u00ed el tipo de dato ser\u00e1 real (float).</p> <pre><code>altura = 1.65\n</code></pre> <p>Ahora podr\u00edamos juntar todo esto en una sola frase, mezclando strings literales (palabras o frases o cualquier conjunto de caracteres) con variables. Copien y peguen lo siguiente en un nuevo programa (recuerden: Ctrl-N para crear un nuevo programa, Ctrl-S para grabar y ponerle nombre -NO olviden que el nombre debe contener SOLAMENTE letras del alfabeto base, sin letras acentuadas ni e\u00f1e, m\u00e1s el caracter gui\u00f3n bajo y DEBE terminar con .py-)</p> <pre><code>nombre = \"Ana\"\nedad = 33\naltura = 1.65\nprint(nombre, \"tiene\", edad, \"a\u00f1os y mide\", altura)\n</code></pre> <p>Al ejecutar, deber\u00edamos ver como salida del programa lo siguiente:</p> <p>Ana tiene 33 a\u00f1os y mide 1.65</p> <p>Como sabe Python cuando poner Ana y cuando poner tiene?</p> <p>Cuando encuentra una palabra que NO est\u00e1 entre comillas, entiende que es una variable y muestra entonces su valor contenido. En cambio, cuando encuentra dentro del print(), letras, palabras o frases o cualquier conjunto de caracteres entre comillas, muestra su contenido literal.</p>"},{"location":"inicio/variables/#como-se-puede-llamar-una-variable","title":"C\u00f3mo se puede llamar una variable?","text":"<p>Debe comenzar con una letra (de preferencia min\u00fascula -en Python, se distinguen las may\u00fasculas de las min\u00fasculas-).</p> <p>Luego puede haber otras letras, tanto min\u00fasculas como may\u00fasculas y tambi\u00e9n n\u00fameros y guiones bajos.</p> <p>Ejemplos de nombres de variables:</p> <p>nombre (nombre de una persona, empresa, o lo que sea) fecha_nacimiento (Fecha de nacimiento en nomenclatura snake case) fechaNacimiento (Fecha de nacimiento en nomenclatura camel case) sueldoBasico periodo2020_2022</p>"},{"location":"inicio/variables/#carga-de-valores-desde-el-teclado","title":"Carga de valores desde el teclado","text":"<p>Las variables pueden recibir un valor por asignaci\u00f3n directa como acabamos de ver:</p> <p>nombre = \"Ana\"</p> <p>o bien desde el teclado.</p> <p>Para ello, se utiliza la funci\u00f3n input(), que nos permite colocar entre sus par\u00e9ntesis un mensaje que le aparecer\u00e1 al usuario para indicarle lo que se pretende que escriba.</p> <pre><code># El mensaje entre comillas sale por la consola como si fuera un print()\n# y el cursor queda esperando que el usuario escriba y finalice con Enter.\n# Luego de eso, lo ingresado queda asignado a la variable.\nnombre = input(\"Ingrese su nombre: \")\nprint(\"Hola\", nombre)\n</code></pre>"},{"location":"objetos/","title":"Orientaci\u00f3n a Objetos","text":"<p>La Programaci\u00f3n Orientada a Objetos (en espa\u00f1ol: POO, en ingl\u00e9s: OOP) es un paradigma (forma de organizaci\u00f3n del c\u00f3digo) de programaci\u00f3n que surgi\u00f3 con el objetivo de mejorar la modelizaci\u00f3n de la realidad. Se trat\u00f3 de eliminar algunos supuestos defectos del paradigma de la Programaci\u00f3n Estructurada.</p>"},{"location":"objetos/#objetivos","title":"Objetivos","text":"<ul> <li>Mayor consistencia: al poner datos y operaciones sobre sobre los mismos dentro de la misma estructura, se reduce el riesgo de desajustes.</li> <li>Mejor reutilizaci\u00f3n: a partir de la Herencia</li> <li>Simplificaci\u00f3n: Abstracci\u00f3n (importa QU\u00c9 hace y no C\u00d3MO)</li> <li>Seguridad y validaci\u00f3n: Acceso m\u00e1s controlado a los datos (Encapsulamiento)</li> <li>Sencillez: el Polimorfismo nos da interfases comunes para objetos diversos.</li> <li>Menor acoplamiento: Mejorar la relaci\u00f3n entre componentes (Composici\u00f3n)</li> </ul>"},{"location":"objetos/#terminologia","title":"Terminolog\u00eda","text":"<ul> <li>Clase: Las clases son moldes, plantillas, planos o, como me dijo un alumno hace algunos a\u00f1os en un examen, \"una clase es una budinera, sirve para hacer budines pero no tengo ning\u00fan bud\u00edn hasta que no hago uno\".</li> <li>Instancia: el objeto propiamente dicho (un bud\u00edn!)</li> <li>Miembros de la clase<ul> <li>Atributo: Caracter\u00edsticas o propiedades de un objeto.</li> <li>M\u00e9todo: Acciones o comportamientos de un objeto.</li> </ul> </li> </ul>"},{"location":"objetos/#clase","title":"Clase","text":""},{"location":"objetos/#objeto","title":"Objeto","text":""},{"location":"objetos/#nomenclatura","title":"Nomenclatura","text":"<p>En Python, la nomenclatura de clases sigue la convenci\u00f3n de usar PascalCase, donde la primera letra de cada palabra en el nombre de la clase se escribe en may\u00fascula. Adem\u00e1s, es recomendable que los nombres de clase sean sustantivos singulares. Ejemplos: Usuario, Producto, Coche, GatoDomestico.</p> <pre><code>class Alumno:\n    def __init__(self, nombre, apellido): # m\u00e9todo constructor\n        self.nombre = nombre # self.nombre es un atributo ...\n        self.apellido = apellido # ... y self.apellido otro atributo\n        inicial = nombre[0].lower() # variable local\n        # y self.mail aunque no viene de par\u00e1metros, tambi\u00e9n es un atributo:\n        self.mail = f'{inicial}.{apellido.lower()}@itecriocuarto.org.ar'\n\n    def nombre_completo(self): # m\u00e9todo\n        return f'{self.nombre} {self.apellido}'\n\n    def promedio(self, *args): # otro m\u00e9todo\n        return sum(args) / len(args)\n\nalumno1 = Alumno('Juan', 'Torres') # instanciaci\u00f3n (creaci\u00f3n del objeto)\nprint(f'El alumno {alumno1.nombre_completo()} tiene este mail: {alumno1.mail}')\nprint(f'Y su promedio es {alumno1.promedio(4,5,7)}')\n</code></pre> <p>Observen que el objeto reemplaza a self en los atributos y en los m\u00e9todos. Siempre va el nombre del objeto, un punto y finalmente el nombre del atributo o m\u00e9todo (este siempre lleva par\u00e9ntesis).</p>"},{"location":"objetos/#listas-de-objetos","title":"Listas de objetos","text":"<p>Las estructuras de datos, como las listas, no solamente pueden almacenar valores de los tipos de datos comunes que ya conoc\u00edamos, sino tambi\u00e9n instancias de clases (objetos).</p> <pre><code>class Alumno:\n    def __init__(self, nombre, apellido): # m\u00e9todo constructor\n        self.nombre = nombre\n        self.apellido = apellido\n        inicial = nombre[0].lower()\n        self.mail = f'{inicial}.{apellido.lower()}@itecriocuarto.org.ar'\n\n    def nombre_completo(self):\n        return f'{self.nombre} {self.apellido}'\n\n    def promedio(self, *args):\n        return sum(args) / len(args)\n\nalumnos: list[Alumno] = [] # VER Tipado expl\u00edcito\nfor i in range(2):\n    nombre_carga = input('Nombre: ')\n    apellido_carga = input('Apellido: ')\n    alumno_carga = Alumno(nombre_carga, apellido_carga) # instanciamos\n    alumnos.append(alumno_carga) # cargamos el objeto en la lista\n\nfor alumno_almacenado in alumnos: # recorremos la lista de objetos 'Alumno'\n# la variable de recorrido es un objeto y dispone de los atributos y m\u00e9todos:\n    print(alumno_almacenado.mail) \n    print(alumno_almacenado.nombre_completo()) \n</code></pre>"},{"location":"objetos/#tipado-explicito","title":"Tipado expl\u00edcito","text":"<p>Ya sabemos que Python no fuerza la declaraci\u00f3n de tipos de datos, sin embargo en la actualidad se considera una buena pr\u00e1ctica, y si bien no se relaciona necesariamente con la OOP, lo traigo aqu\u00ed porque, adem\u00e1s del aporte a la legibilidad, sirve de mucha ayuda para el autocompletado y la visibilidad de los errores cuando usamos editores como Visual Studio Code, sus derivados y la mayor\u00eda de los m\u00e1s utilizados.</p> <pre><code>nombre: str = 'Ana' # se puede declarar junto con la asignaci\u00f3n\n\nedad: int # o bien declarar ...\nedad = 22 # ... y luego asignar\n\negresado: bool = False\n\n# en las listas y tuplas se pone entre corchetes el tipo de los valores\nnombres: list[str] = ['Ana', 'Luis']\n\n# en un diccionario, habitualmente 'str' para la clave y otro tipo de dato\n# para el valor o bien 'object' si queremos que pueda ser cualquiera:\npersona: dict[str, object] = {'nombre': 'Ana', 'edad': 22, 'notas': [4, 7]}\n\n# las funciones pueden tener tipo de retorno o None cuando no devuelven nada\ndef main() -&gt; None:\n    print('Yo soy main')\n\ndef saludo(nombre: str) -&gt; str: # los par\u00e1metros tambi\u00e9n (esto es muy \u00fatil !!!)\n    return f'Hola {nombre}!'\n\nprint(saludo('Juan'))\n\n# y se puede anidar estructuras m\u00e1s complejas como aqu\u00ed:\npersonas: list[dict[str, object]] = [\n    {'nombre': 'Juan', 'edad': 35},\n    {'nombre': 'Ana', 'edad': 23}\n]   \n</code></pre>"},{"location":"objetos/class_members-old/","title":"Miembros de Clase (atributos y m\u00e9todos de clase)","text":"<p>Estar\u00e1 disponible para el m\u00f3dulo 13!</p>"},{"location":"objetos/class_members/","title":"Miembros de Clase (atributos y m\u00e9todos de clase)","text":"<p>Los atributos y m\u00e9todos de clase son aquellos que aplican a la totalidad de las instancias (objetos) que se crean.</p> <p>Por ejemplo, si tenemos una clase GatoDomestico, cada instancia (cada objeto gato que se cree), podr\u00e1 tener su atributo nombre espec\u00edfico, su edad, su comportamiento, etc. Pero todos ellos ser\u00e1n de la especie Felis Catus, por lo tanto, especie ser\u00e1 un atributo de clase, en lugar de ser un atributo de instancia.</p> <p>A diferencia de los miembros de instancia, en lugar de usar solamente self, se utiliza cls para hacer referencia espec\u00edfica a la clase. Aunque con self tambi\u00e9n se puede acceder desde una instancia a un atributo de clase.</p> <pre><code># atributos y m\u00e9todos de clases\nclass Persona:\n    especie = 'Homo Sapiens' # atributo de clase (aplica a todos los objetos)\n\n    def __init__(self, nombre, edad) -&gt; None:\n        self.nombre = nombre # atributos de instancia \n        self.edad = edad\n\n    def __str__(self):\n        return f'Especie:{self.especie} Nombre:{self.nombre} Edad:{self.edad}'\n\n    @classmethod\n    def desde_datos(cls, persona_datos): #constructor alternativo\n        nombre, edad = persona_datos.split('-')\n        edad = int(edad)\n        return cls(nombre, edad)\n\n    @classmethod\n    def set_especie(cls, nombre) -&gt; None:\n        cls.especie = nombre\n\nalguien = Persona('Ana', 22)\nprint(alguien)\notra_persona = Persona('Juan', 35)\nprint(otra_persona)\ndato1 = 'Luis-61'\notra_persona_mas = Persona.desde_datos(dato1)\nprint(otra_persona_mas)\nPersona.set_especie('Homo Neanderthalensis')\nprint(alguien)\nprint(otra_persona)\n</code></pre>"},{"location":"objetos/dunders-old/","title":"M\u00e9todos M\u00e1gicos (dunders)","text":"<p>Estar\u00e1 disponible para el m\u00f3dulo 12!</p>"},{"location":"objetos/dunders/","title":"M\u00e9todos M\u00e1gicos (dunders)","text":"<p>Los dunders son m\u00e9todos especiales que est\u00e1n disponibles de manera autom\u00e1tica en cualquier clase de python.</p> <p>Los m\u00e1s usuales son:</p> <ul> <li>repr: Para mostrar una representaci\u00f3n del objeto \u00fatil para el Desarrollador</li> <li>str: Para una salida legible para el usuario</li> <li>len: Redefine el uso de la funci\u00f3n len (por ejemplo para saber la cantidad de elementos que tiene un atributo lista)</li> <li>add: Sobrecarga de operador (redefine el comportamiento del signo + para operaciones entre objetos)</li> <li>getitem: Permite acceder a elementos usando la sintaxis de corchetes (mi_lista[0], mi_lista[1], etc.)</li> </ul> <p>Y varios m\u00e1s ...</p> <pre><code>class Color:\n    def __init__(self, nombre) -&gt; None:\n        self.nombre = nombre\n\n    def __add__(self, otro_color): # sobrecarga de operador +\n        if self.nombre == 'azul' and otro_color.nombre == 'rojo':\n            return Color('violeta')\n        else:\n            return Color('inexistente')\n\n    def __repr__(self): # salida para programadores\n        return f'Clase: {self.__class__.__name__}, Nombre: {self.nombre}'\n\n    def __str__(self): # Para el usuario\n        return f'Color {self.nombre}'\n\nazul = Color('azul')\nrojo = Color('rojo')\namarillo = Color('amarillo')\n\ncolor_nuevo = azul + rojo\nprint(color_nuevo)\n</code></pre> <p>Y otro ejemplo:</p> <pre><code>class MiLista:\n    def __init__(self):\n        self.items = []\n\n    def agregar(self, item):\n        self.items.append(item)\n\n    def __len__(self):\n        \"\"\"Define qu\u00e9 devuelve len(objeto)\"\"\"\n        return len(self.items)\n\n    def __getitem__(self, indice):\n        \"\"\"Permite acceder a elementos usando obj[indice]\"\"\"\n        return self.items[indice]\n\n    def __repr__(self):\n        return f\"MiLista({self.items})\"\n\n# Ejemplo de uso\nmi_lista = MiLista()\nmi_lista.agregar(\"manzana\")\nmi_lista.agregar(\"banana\")\nmi_lista.agregar(\"naranja\")\n\nprint(f\"Mi lista: {mi_lista}\")\nprint(f\"Longitud: {len(mi_lista)}\")  # Usa __len__\nprint(f\"Primer elemento: {mi_lista[0]}\")  # Usa __getitem__\nprint(f\"Segundo elemento: {mi_lista[1]}\")  # Usa __getitem__\nprint(f\"\u00daltimo elemento: {mi_lista[-1]}\")  # Usa __getitem__\n\n# Tambi\u00e9n funciona con slicing\nprint(f\"Primeros dos: {mi_lista[0:2]}\")  # Usa __getitem__ con slice\n</code></pre>"},{"location":"objetos/encapsulamiento/","title":"Encapsulamiento","text":"<p>El encapsulamiento consiste en el acceso a los atributos solamente a trav\u00e9s de m\u00e9todos, NO de forma directa. Es decir que si yo tengo, por ejemplo, un atributo nombre, tanto sea para asignarlo como para obtener su valor, tengo que definir m\u00e9todos que hagan esa tarea. Por convenci\u00f3n, se les llama setters (m\u00e9todos que asignan) y getters (m\u00e9todos que obtienen). En Python, esto no es obligatorio (siempre puedo seguir accediendo a los atributos directamente), pero se considera una buena pr\u00e1ctica.</p> <p>En lugar de hacer esto:</p> <pre><code>class Persona:\n    def __init__(self, edad) -&gt; None:\n        self.edad = edad\n\npersona = Persona(35)\nprint(persona.edad) # esto se quiere evitar (aunque funciona)\n</code></pre> <p>Es m\u00e1s recomendable (en principio) hacer esto:</p> <pre><code>class Persona:\n    def __init__(self, edad) -&gt; None:\n        self.set_edad(edad)\n\n    def get_edad(self): # getter (get == obtener)\n        return f'Edad: {self.edad}'\n\n    def set_edad(self, nueva_edad): # setter (set == asignar)\n        if nueva_edad &gt; 0:\n            self.edad = nueva_edad\n        else:\n            print('No puede tener edad negativa')\n            self.edad = None\n\npersona = Persona(11)\nprint(persona.get_edad())\notra_persona = Persona(-35)\nprint(otra_persona.get_edad())\n</code></pre> <p>Lo primero que se puede observar es que al convocar al setter en el constructor, permite validar el argumento de entrada (en este caso, impedir edad negativa).</p> <p>Sin embargo, la forma m\u00e1s pit\u00f3nica es usar decoradores (funciones especiales que modifican el comportamiento de los m\u00e9todos):</p> <pre><code>class Persona:\n    def __init__(self, edad) -&gt; None:\n        # La l\u00ednea que sigue PARECE que asigna el par\u00e1metro al atributo...\n        # ... pero en realidad, convoca al setter\n        self.edad = edad\n\n    @property # decorador\n    def edad(self): # getter\n        return f'La edad es {self._edad}'\n\n    @edad.setter # decorador\n    def edad(self, nueva_edad): # setter\n        if nueva_edad &lt; 0:\n            print('No puede tener edad negativa!')\n            self._edad = None\n        else:\n            self._edad = nueva_edad # este es el atributo VERDADERO\n\npersona = Persona(10) # el valor va al setter que lo valida\n# la siguiente l\u00ednea PARECE mostrar el atributo...\n# ... pero est\u00e1 convocando al getter\nprint(persona.edad) # el atributo real es _edad (con _ adelante)\notra_persona = Persona(-9)\nprint(otra_persona.edad)\n</code></pre> <p>Un ejemplo casi igual pero con carteles para ir mostrando el flujo de ejecuci\u00f3n, adem\u00e1s aqu\u00ed se usa la instrucci\u00f3n raise que funciona como un return que es capturado por el except:</p> <pre><code>class Persona:\n    def __init__(self, edad):\n        print('\u2983constructor', end=' ')\n        self.edad = edad\n        print('constructor\u2984', end=' ')\n\n    @property # decorador \n    def edad(self): # getter (get == obtiene)\n        print('\u2983get', end=' ')\n        return f'Edad: {self._edad}\u2984' # este es el atributo VERDADERO\n\n    @edad.setter \n    def edad(self, nueva_edad): # setter (set == asigna)\n        print('\u2983set', end=' ')\n        if nueva_edad &lt; 0:\n            raise ValueError(\"La edad no puede ser negativa.\")\n        self._edad = nueva_edad # este es el atributo VERDADERO\n        print(f'{self._edad=}', end=' ')\n        print('set\u2984', end=' ')\n\n\npersona = Persona(10)\nprint(persona.edad)\n\ntry:\n    otra_persona = Persona(-30)\nexcept ValueError as error:\n    print(f'Mensaje de error devuelto por el raise: {error}')\n\n#p1.edad(50) # No funciona as\u00ed el setter\npersona.edad = 50 # ahora si!\nprint()\nprint(f'\u2983 {persona.edad=} \u2984') # este es el GETTER\nprint(f'\u2983 {persona._edad=} \u2984') # este es el atributo VERDADERO\n</code></pre> <p>Nomenclatura de atributos</p> <p>Por convenci\u00f3n, los atributos se muestran como \"privados\" al colocar uno o dos guiones bajos al comienzo de sus nombres.</p> <p>Ejemplo: _nombre o __nombre</p> <p>De cualquier manera, siempre pueden ser accedidos directamente ya que Python no tiene atributos REALMENTE inaccesibles. La diferencia entre ambos existe en la forma de acceso directo, pero es una decisi\u00f3n de nomenclatura y no cambia demasiado. Se los llama de varios modos (privacidad d\u00e9bil y fuerte, por ejemplo) pero elijan libremente cual usar.</p>"},{"location":"objetos/encapsulamiento_old/","title":"Encapsulamiento","text":"<p>Estar\u00e1 disponible para el m\u00f3dulo 11!</p>"}]}